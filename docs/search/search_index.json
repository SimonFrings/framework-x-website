{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Framework X documentation \u00b6 This folder contains the source documentation files for Framework X. You can see the website for the user-accessible version. Contribute \u00b6 Found a typo or want to contribute? This folder contains everything you need to help out with the documentation. We use mkdocs-material to render our documentation to a pretty HTML version. If you want to contribute to the documentation, it's easiest to just run this in a Docker container in the project root directory like this: $ docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material You can access the documentation via http://localhost:8000 . Props to mkdocs, this uses live reloading, so that every change you do while this Docker container is running should immediately be reflected in your web browser. If you want to generate a static HTML folder for deployment, you can again use a Docker container in the project root directory like this: $ docker run --rm -it -v ${ PWD } :/docs squidfunk/mkdocs-material build The resulting build/docs/ should then be deployed behind a web server. See also the Framework X website repository for more details about the website itself. If you want to add a new documentation file and/or change the page order, make sure the mkdocs.yml file in the project root directory contains an up-to-date list of all pages. Happy hacking!","title":"Framework X documentation"},{"location":"#framework-x-documentation","text":"This folder contains the source documentation files for Framework X. You can see the website for the user-accessible version.","title":"Framework X documentation"},{"location":"#contribute","text":"Found a typo or want to contribute? This folder contains everything you need to help out with the documentation. We use mkdocs-material to render our documentation to a pretty HTML version. If you want to contribute to the documentation, it's easiest to just run this in a Docker container in the project root directory like this: $ docker run --rm -it -p 8000 :8000 -v ${ PWD } :/docs squidfunk/mkdocs-material You can access the documentation via http://localhost:8000 . Props to mkdocs, this uses live reloading, so that every change you do while this Docker container is running should immediately be reflected in your web browser. If you want to generate a static HTML folder for deployment, you can again use a Docker container in the project root directory like this: $ docker run --rm -it -v ${ PWD } :/docs squidfunk/mkdocs-material build The resulting build/docs/ should then be deployed behind a web server. See also the Framework X website repository for more details about the website itself. If you want to add a new documentation file and/or change the page order, make sure the mkdocs.yml file in the project root directory contains an up-to-date list of all pages. Happy hacking!","title":"Contribute"},{"location":"api/app/","text":"App \u00b6 The App class is your main entrypoint to any application that builds on top of X. It provides a simple API for routing HTTP requests as commonly used in RESTful applications. # app.php <?php require __DIR__ . '/vendor/autoload.php' ; $app = new FrameworkX\\App (); // Register routes here, see routing\u2026 $app -> run (); Routing \u00b6 The App class offers a number of API methods that allow you to route incoming HTTP requests to controller functions. In its most simple form, you can add multiple routes using inline closures like this: $app->get('/user', function () { return new React\\Http\\Message\\Response(200, [], \"hello everybody!\"); }); $app->get('/user/{id}', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $id = $request->getAttribute('id'); return new React\\Http\\Message\\Response(200, [], \"hello $id\"); }); For example, an HTTP GET request for /user would call the first controller function. An HTTP GET request for /user/alice would call the second controller function which also highlights how you can use request attributes to access values from URI templates. An HTTP GET request for /foo would automatically reject the HTTP request with a 404 Not Found error response unless this route is registered. Likewise, an HTTP POST request for /user would reject with a 405 Method Not Allowed error response unless a route for this method is also registered. You can route any number of incoming HTTP requests to controller functions by using the matching API methods like this: $app->get('/user/{id}', $controller); $app->head('/user/{id}', $controller); $app->post('/user/{id}', $controller); $app->put('/user/{id}', $controller); $app->patch('/user/{id}', $controller); $app->delete('/user/{id}', $controller); $app->options('/user/{id}', $controller); If you want to map multiple HTTP request methods to a single controller, you can use this shortcut instead of listing each method explicitly like above: $app->map(['GET', 'POST'], '/user/{id}', $controller); If you want to map each and every HTTP request method to a single controller, you can use this additional shortcut: $app->any('/user/{id}', $controller); Redirects \u00b6 The App also offers a convenient helper method to redirect a matching route to a new URL like this: $app->redirect('/promo/reactphp', 'http://reactphp.org/'); Browsers and search engine crawlers will automatically follow the redirect with the 302 Found status code by default. You can optionally pass a custom redirect status code in the 3xx range to use. If this is a permanent redirect, you may want to use the 301 Permanent Redirect status code to instruct search engine crawlers to update their index like this: $app->redirect('/blog.html', '/blog', 301); See response status codes for more details. Controllers \u00b6 The above examples use inline closures as controller functions to make these examples more concise: $app->get('/', function () { return new React\\Http\\Message\\Response( 200, [], \"Hello w\u00f6rld!\\n\" ); }); While easy to get started, it's easy to see how this would become a mess once you keep adding more controllers to a single application. For this reason, we recommend using controller classes for production use-cases like this: # app.php $app->get('/', new Acme\\Todo\\HelloController()); # src/HelloController.php <?php namespace Acme\\Todo ; use React\\Http\\Message\\Response ; class HelloController { public function __invoke () { return new Response ( 200 , [], \"Hello w\u00f6rld! \\n \" ); } } See controller classes for more details. Middleware \u00b6 One of the main features of the App is middleware support. Middleware allows you to extract common functionality such as HTTP login, session handling or logging into reusable components. These middleware components can be added to both individual routes or globally to all registered routes. See middleware documentation for more details.","title":"App"},{"location":"api/app/#app","text":"The App class is your main entrypoint to any application that builds on top of X. It provides a simple API for routing HTTP requests as commonly used in RESTful applications. # app.php <?php require __DIR__ . '/vendor/autoload.php' ; $app = new FrameworkX\\App (); // Register routes here, see routing\u2026 $app -> run ();","title":"App"},{"location":"api/app/#routing","text":"The App class offers a number of API methods that allow you to route incoming HTTP requests to controller functions. In its most simple form, you can add multiple routes using inline closures like this: $app->get('/user', function () { return new React\\Http\\Message\\Response(200, [], \"hello everybody!\"); }); $app->get('/user/{id}', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $id = $request->getAttribute('id'); return new React\\Http\\Message\\Response(200, [], \"hello $id\"); }); For example, an HTTP GET request for /user would call the first controller function. An HTTP GET request for /user/alice would call the second controller function which also highlights how you can use request attributes to access values from URI templates. An HTTP GET request for /foo would automatically reject the HTTP request with a 404 Not Found error response unless this route is registered. Likewise, an HTTP POST request for /user would reject with a 405 Method Not Allowed error response unless a route for this method is also registered. You can route any number of incoming HTTP requests to controller functions by using the matching API methods like this: $app->get('/user/{id}', $controller); $app->head('/user/{id}', $controller); $app->post('/user/{id}', $controller); $app->put('/user/{id}', $controller); $app->patch('/user/{id}', $controller); $app->delete('/user/{id}', $controller); $app->options('/user/{id}', $controller); If you want to map multiple HTTP request methods to a single controller, you can use this shortcut instead of listing each method explicitly like above: $app->map(['GET', 'POST'], '/user/{id}', $controller); If you want to map each and every HTTP request method to a single controller, you can use this additional shortcut: $app->any('/user/{id}', $controller);","title":"Routing"},{"location":"api/app/#redirects","text":"The App also offers a convenient helper method to redirect a matching route to a new URL like this: $app->redirect('/promo/reactphp', 'http://reactphp.org/'); Browsers and search engine crawlers will automatically follow the redirect with the 302 Found status code by default. You can optionally pass a custom redirect status code in the 3xx range to use. If this is a permanent redirect, you may want to use the 301 Permanent Redirect status code to instruct search engine crawlers to update their index like this: $app->redirect('/blog.html', '/blog', 301); See response status codes for more details.","title":"Redirects"},{"location":"api/app/#controllers","text":"The above examples use inline closures as controller functions to make these examples more concise: $app->get('/', function () { return new React\\Http\\Message\\Response( 200, [], \"Hello w\u00f6rld!\\n\" ); }); While easy to get started, it's easy to see how this would become a mess once you keep adding more controllers to a single application. For this reason, we recommend using controller classes for production use-cases like this: # app.php $app->get('/', new Acme\\Todo\\HelloController()); # src/HelloController.php <?php namespace Acme\\Todo ; use React\\Http\\Message\\Response ; class HelloController { public function __invoke () { return new Response ( 200 , [], \"Hello w\u00f6rld! \\n \" ); } } See controller classes for more details.","title":"Controllers"},{"location":"api/app/#middleware","text":"One of the main features of the App is middleware support. Middleware allows you to extract common functionality such as HTTP login, session handling or logging into reusable components. These middleware components can be added to both individual routes or globally to all registered routes. See middleware documentation for more details.","title":"Middleware"},{"location":"api/middleware/","text":"Middleware \u00b6 \u2139\ufe0f New to middleware? Middleware allows modifying the incoming request and outgoing response messages and extracting this logic into reusable components. This is frequently used for common functionality such as HTTP login, session handling, logging, and much more. Inline middleware functions \u00b6 Middleware is any piece of logic that will wrap around your request handler. You can add any number of middleware handlers to each route. To get started, let's take a look at a basic middleware handler by adding an additional callable before the final controller like this: <?php $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request , callable $next ) { // optionally return response without passing to next handler // return new React\\Http\\Message\\Response(403, [], \"Forbidden!\\n\"); // optionally modify request before passing to next handler // $request = $request->withAttribute('admin', false); // call next handler in chain $response = $next ( $request ); assert ( $response instanceof Psr\\Http\\Message\\ResponseInterface ); // optionally modify response before returning to previous handler // $response = $response->withHeader('Content-Type', 'text/plain'); return $response ; }, function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $role = $request -> getAttribute ( 'admin' ) ? 'admin' : 'user' ; return new React\\Http\\Message\\Response ( 200 , [], \"Hello $role ! \\n \" ); } ); This example shows how you could build your own middleware that can modifying the incoming request and outgoing response messages alike. Each middleware is responsible for calling the next handler in the chain or directly returning an error response if the request should not be processed. Middleware classes \u00b6 While inline functions are easy to get started, it's easy to see how this would become a mess once you keep adding more controllers to a single application. For this reason, we recommend using middleware classes for production use-cases like this: # src/DemoMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; class DemoMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { // optionally return response without passing to next handler // return new React\\Http\\Message\\Response(403, [], \"Forbidden!\\n\"); // optionally modify request before passing to next handler // $request = $request->withAttribute('admin', false); // call next handler in chain $response = $next ( $request ); assert ( $response instanceof ResponseInterface ); // optionally modify response before returning to previous handler // $response = $response->withHeader('Content-Type', 'text/plain'); return $response ; } } # app.php <?php use Acme\\Todo\\DemoMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , new DemoMiddleware (), new UserController ()); This highlights how middleware classes provide the exact same functionaly as using inline functions, yet provide a cleaner and more reusable structure. Accordingly, all examples below use middleware classes as the recommended style. \u2139\ufe0f New to Composer autoloading? This example uses namespaced classes as the recommended way in the PHP ecosystem. If you're new to setting up your project structure, see also controller classes for more details. Request middleware \u00b6 To get started, we can add an example middleware handler that can modify the incoming request: # src/AdminMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; class AdminMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $ip = $request -> getServerParams ()[ 'REMOTE_ADDR' ]; if ( $ip === '127.0.0.1' ) { $request = $request -> withAttribute ( 'admin' , true ); } return $next ( $request ); } } # src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { $role = $request -> getAttribute ( 'admin' ) ? 'admin' : 'user' ; return new Response ( 200 , [], \"Hello $role ! \\n \" ); } } # app.php <?php use Acme\\Todo\\AdminMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , new AdminMiddleware (), new UserController ()); For example, an HTTP GET request for /user would first call the middleware handler which then modifies this request and passes the modified request to the next controller function. This is commonly used for HTTP authentication, login handling and session handling. Note that this example only modifies the incoming request object and simply returns whatever the next request handler returns without modifying the outgoing response. This means this works both when the next request handler returns a response object synchronously or if you're using an async request handler that may return a promise or coroutine . If you want to modify the outgoing response object, see also the next chapter. Response middleware \u00b6 Likewise, we can add an example middleware handler that can modify the outgoing response: # src/ContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; class ContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); assert ( $response instanceof ResponseInterface ); return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } # src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { $name = 'Alice' ; return new Response ( 200 , [], \"Hello $name ! \\n \" ); } } # app.php <?php use Acme\\Todo\\ContentTypeMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , new ContentTypeMiddleware (), new UserController ()); For example, an HTTP GET request for /user would first call the middleware handler which passes on the request to the controller function and then modifies the response that is returned by the controller function. This is commonly used for cache handling and response body transformations (compression etc.). Note that this example assumes the next request handler returns a response object synchronously. If you're writing a middleware that also needs to support async request handlers that may return a promise or coroutine , see also the next chapter. Async middleware \u00b6 One of the core features of X is its async support. As a consequence, each middleware handler can also return promises or coroutines . While request middleware doesn't usually have to care about async responses, this particularly affects response middleware that wants to change the outgoing response. Here's an example middleware handler that can modify the outgoing response no matter whether the next request handler returns a promise , a coroutine or a response object synchronously: Arrow functions (PHP 7.4+) # src/AsyncAwareContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Promise\\PromiseInterface ; class AsyncContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); if ( $response instanceof PromiseInterface ) { return $response -> then ( fn ( ResponseInterface $response ) => $this -> handle ( $response )); } elseif ( $response instanceof \\Generator ) { return ( fn () => $this -> handle ( yield from $response ))(); } else { return $this -> handle ( $response ); } } private function handle ( ResponseInterface $response ) : ResponseInterface { return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } Match syntax (PHP 8.0+) # src/AsyncAwareContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Promise\\PromiseInterface ; class AsyncContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); return match ( true ) { $response instanceof PromiseInterface => $response -> then ( fn ( ResponseInterface $response ) => $this -> handle ( $response )), $response instanceof \\Generator => ( fn () => $this -> handle ( yield from $response ))(), default => $this -> handle ( $response ), }; } private function handle ( ResponseInterface $response ) : ResponseInterface { return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } Closures # src/AsyncAwareContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Promise\\PromiseInterface ; class AsyncContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); if ( $response instanceof PromiseInterface ) { return $response -> then ( function ( ResponseInterface $response ) { return $this -> handle ( $response ); }); } elseif ( $response instanceof \\Generator ) { return ( function () use ( $response ) { return $this -> handle ( yield from $response ); })(); } else { return $this -> handle ( $response ); } } private function handle ( ResponseInterface $response ) : ResponseInterface { return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } Coroutines # src/AsyncUserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\EventLoop\\Loop ; use React\\Http\\Message\\Response ; use React\\Promise\\Promise ; use React\\Promise\\PromiseInterface ; class AsyncUserController { public function __invoke ( ServerRequestInterface $request ) : \\Generator { // async pseudo code to load some data from an external source $promise = $this -> fetchRandomUserName (); $name = yield $promise ; assert ( is_string ( $name )); return new Response ( 200 , [], \"Hello $name ! \\n \" ); } /** * @return PromiseInterface<string> */ private function fetchRandomUserName () : PromiseInterface { return new Promise ( function ( $resolve ) { Loop :: addTimer ( 0.01 , function () use ( $resolve ) { $resolve ( 'Alice' ); }); }); } } Promises # src/AsyncUserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\EventLoop\\Loop ; use React\\Http\\Message\\Response ; use React\\Promise\\Promise ; use React\\Promise\\PromiseInterface ; class AsyncUserController { /** * @return PromiseInterface<Response> */ public function __invoke ( ServerRequestInterface $request ) : PromiseInterface { // async pseudo code to load some data from an external source return $this -> fetchRandomUserName () -> then ( function ( string $name ) { return new Response ( 200 , [], \"Hello $name ! \\n \" ); }); } /** * @return PromiseInterface<string> */ private function fetchRandomUserName () : PromiseInterface { return new Promise ( function ( $resolve ) { Loop :: addTimer ( 0.01 , function () use ( $resolve ) { $resolve ( 'Alice' ); }); }); } } # app.php <?php use Acme\\Todo\\AsyncContentTypeMiddleware ; use Acme\\Todo\\AsyncUserController ; // \u2026 $app -> get ( '/user' , new AsyncContentTypeMiddleware (), new AsyncUserController ()); For example, an HTTP GET request for /user would first call the middleware handler which passes on the request to the controller function and then modifies the response that is returned by the controller function. This is commonly used for cache handling and response body transformations (compression etc.). \ud83d\udd2e Future fiber support in PHP 8.1 In the future, PHP 8.1 will provide native support for fibers . Once fibers become mainstream, we can simplify this example significantly because we wouldn't have to use promises or Generator-based coroutines anymore. See fibers for more details. Global middleware \u00b6 Additionally, you can also add middleware to the App object itself to register a global middleware handler: # app.php <?php use Acme\\Todo\\AdminMiddleware ; use Acme\\Todo\\UserController ; $app = new FrameworkX\\App ( new AdminMiddleware ()); $app -> get ( '/user' , new UserController ()); $app -> run (); Any global middleware handler will always be called for all registered routes and also any requests that can not be routed. You can also combine global middleware handlers (think logging) with additional middleware handlers for individual routes (think authentication). Global middleware handlers will always be called before route middleware handlers.","title":"Middleware"},{"location":"api/middleware/#middleware","text":"\u2139\ufe0f New to middleware? Middleware allows modifying the incoming request and outgoing response messages and extracting this logic into reusable components. This is frequently used for common functionality such as HTTP login, session handling, logging, and much more.","title":"Middleware"},{"location":"api/middleware/#inline-middleware-functions","text":"Middleware is any piece of logic that will wrap around your request handler. You can add any number of middleware handlers to each route. To get started, let's take a look at a basic middleware handler by adding an additional callable before the final controller like this: <?php $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request , callable $next ) { // optionally return response without passing to next handler // return new React\\Http\\Message\\Response(403, [], \"Forbidden!\\n\"); // optionally modify request before passing to next handler // $request = $request->withAttribute('admin', false); // call next handler in chain $response = $next ( $request ); assert ( $response instanceof Psr\\Http\\Message\\ResponseInterface ); // optionally modify response before returning to previous handler // $response = $response->withHeader('Content-Type', 'text/plain'); return $response ; }, function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { $role = $request -> getAttribute ( 'admin' ) ? 'admin' : 'user' ; return new React\\Http\\Message\\Response ( 200 , [], \"Hello $role ! \\n \" ); } ); This example shows how you could build your own middleware that can modifying the incoming request and outgoing response messages alike. Each middleware is responsible for calling the next handler in the chain or directly returning an error response if the request should not be processed.","title":"Inline middleware functions"},{"location":"api/middleware/#middleware-classes","text":"While inline functions are easy to get started, it's easy to see how this would become a mess once you keep adding more controllers to a single application. For this reason, we recommend using middleware classes for production use-cases like this: # src/DemoMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; class DemoMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { // optionally return response without passing to next handler // return new React\\Http\\Message\\Response(403, [], \"Forbidden!\\n\"); // optionally modify request before passing to next handler // $request = $request->withAttribute('admin', false); // call next handler in chain $response = $next ( $request ); assert ( $response instanceof ResponseInterface ); // optionally modify response before returning to previous handler // $response = $response->withHeader('Content-Type', 'text/plain'); return $response ; } } # app.php <?php use Acme\\Todo\\DemoMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , new DemoMiddleware (), new UserController ()); This highlights how middleware classes provide the exact same functionaly as using inline functions, yet provide a cleaner and more reusable structure. Accordingly, all examples below use middleware classes as the recommended style. \u2139\ufe0f New to Composer autoloading? This example uses namespaced classes as the recommended way in the PHP ecosystem. If you're new to setting up your project structure, see also controller classes for more details.","title":"Middleware classes"},{"location":"api/middleware/#request-middleware","text":"To get started, we can add an example middleware handler that can modify the incoming request: # src/AdminMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; class AdminMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $ip = $request -> getServerParams ()[ 'REMOTE_ADDR' ]; if ( $ip === '127.0.0.1' ) { $request = $request -> withAttribute ( 'admin' , true ); } return $next ( $request ); } } # src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { $role = $request -> getAttribute ( 'admin' ) ? 'admin' : 'user' ; return new Response ( 200 , [], \"Hello $role ! \\n \" ); } } # app.php <?php use Acme\\Todo\\AdminMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , new AdminMiddleware (), new UserController ()); For example, an HTTP GET request for /user would first call the middleware handler which then modifies this request and passes the modified request to the next controller function. This is commonly used for HTTP authentication, login handling and session handling. Note that this example only modifies the incoming request object and simply returns whatever the next request handler returns without modifying the outgoing response. This means this works both when the next request handler returns a response object synchronously or if you're using an async request handler that may return a promise or coroutine . If you want to modify the outgoing response object, see also the next chapter.","title":"Request middleware"},{"location":"api/middleware/#response-middleware","text":"Likewise, we can add an example middleware handler that can modify the outgoing response: # src/ContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; class ContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); assert ( $response instanceof ResponseInterface ); return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } # src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { $name = 'Alice' ; return new Response ( 200 , [], \"Hello $name ! \\n \" ); } } # app.php <?php use Acme\\Todo\\ContentTypeMiddleware ; use Acme\\Todo\\UserController ; // \u2026 $app -> get ( '/user' , new ContentTypeMiddleware (), new UserController ()); For example, an HTTP GET request for /user would first call the middleware handler which passes on the request to the controller function and then modifies the response that is returned by the controller function. This is commonly used for cache handling and response body transformations (compression etc.). Note that this example assumes the next request handler returns a response object synchronously. If you're writing a middleware that also needs to support async request handlers that may return a promise or coroutine , see also the next chapter.","title":"Response middleware"},{"location":"api/middleware/#async-middleware","text":"One of the core features of X is its async support. As a consequence, each middleware handler can also return promises or coroutines . While request middleware doesn't usually have to care about async responses, this particularly affects response middleware that wants to change the outgoing response. Here's an example middleware handler that can modify the outgoing response no matter whether the next request handler returns a promise , a coroutine or a response object synchronously: Arrow functions (PHP 7.4+) # src/AsyncAwareContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Promise\\PromiseInterface ; class AsyncContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); if ( $response instanceof PromiseInterface ) { return $response -> then ( fn ( ResponseInterface $response ) => $this -> handle ( $response )); } elseif ( $response instanceof \\Generator ) { return ( fn () => $this -> handle ( yield from $response ))(); } else { return $this -> handle ( $response ); } } private function handle ( ResponseInterface $response ) : ResponseInterface { return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } Match syntax (PHP 8.0+) # src/AsyncAwareContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Promise\\PromiseInterface ; class AsyncContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); return match ( true ) { $response instanceof PromiseInterface => $response -> then ( fn ( ResponseInterface $response ) => $this -> handle ( $response )), $response instanceof \\Generator => ( fn () => $this -> handle ( yield from $response ))(), default => $this -> handle ( $response ), }; } private function handle ( ResponseInterface $response ) : ResponseInterface { return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } Closures # src/AsyncAwareContentTypeMiddleware.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ResponseInterface ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Promise\\PromiseInterface ; class AsyncContentTypeMiddleware { public function __invoke ( ServerRequestInterface $request , callable $next ) { $response = $next ( $request ); if ( $response instanceof PromiseInterface ) { return $response -> then ( function ( ResponseInterface $response ) { return $this -> handle ( $response ); }); } elseif ( $response instanceof \\Generator ) { return ( function () use ( $response ) { return $this -> handle ( yield from $response ); })(); } else { return $this -> handle ( $response ); } } private function handle ( ResponseInterface $response ) : ResponseInterface { return $response -> withHeader ( 'Content-Type' , 'text/plain' ); } } Coroutines # src/AsyncUserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\EventLoop\\Loop ; use React\\Http\\Message\\Response ; use React\\Promise\\Promise ; use React\\Promise\\PromiseInterface ; class AsyncUserController { public function __invoke ( ServerRequestInterface $request ) : \\Generator { // async pseudo code to load some data from an external source $promise = $this -> fetchRandomUserName (); $name = yield $promise ; assert ( is_string ( $name )); return new Response ( 200 , [], \"Hello $name ! \\n \" ); } /** * @return PromiseInterface<string> */ private function fetchRandomUserName () : PromiseInterface { return new Promise ( function ( $resolve ) { Loop :: addTimer ( 0.01 , function () use ( $resolve ) { $resolve ( 'Alice' ); }); }); } } Promises # src/AsyncUserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\EventLoop\\Loop ; use React\\Http\\Message\\Response ; use React\\Promise\\Promise ; use React\\Promise\\PromiseInterface ; class AsyncUserController { /** * @return PromiseInterface<Response> */ public function __invoke ( ServerRequestInterface $request ) : PromiseInterface { // async pseudo code to load some data from an external source return $this -> fetchRandomUserName () -> then ( function ( string $name ) { return new Response ( 200 , [], \"Hello $name ! \\n \" ); }); } /** * @return PromiseInterface<string> */ private function fetchRandomUserName () : PromiseInterface { return new Promise ( function ( $resolve ) { Loop :: addTimer ( 0.01 , function () use ( $resolve ) { $resolve ( 'Alice' ); }); }); } } # app.php <?php use Acme\\Todo\\AsyncContentTypeMiddleware ; use Acme\\Todo\\AsyncUserController ; // \u2026 $app -> get ( '/user' , new AsyncContentTypeMiddleware (), new AsyncUserController ()); For example, an HTTP GET request for /user would first call the middleware handler which passes on the request to the controller function and then modifies the response that is returned by the controller function. This is commonly used for cache handling and response body transformations (compression etc.). \ud83d\udd2e Future fiber support in PHP 8.1 In the future, PHP 8.1 will provide native support for fibers . Once fibers become mainstream, we can simplify this example significantly because we wouldn't have to use promises or Generator-based coroutines anymore. See fibers for more details.","title":"Async middleware"},{"location":"api/middleware/#global-middleware","text":"Additionally, you can also add middleware to the App object itself to register a global middleware handler: # app.php <?php use Acme\\Todo\\AdminMiddleware ; use Acme\\Todo\\UserController ; $app = new FrameworkX\\App ( new AdminMiddleware ()); $app -> get ( '/user' , new UserController ()); $app -> run (); Any global middleware handler will always be called for all registered routes and also any requests that can not be routed. You can also combine global middleware handlers (think logging) with additional middleware handlers for individual routes (think authentication). Global middleware handlers will always be called before route middleware handlers.","title":"Global middleware"},{"location":"api/request/","text":"Request \u00b6 Whenever the client sends an HTTP request to our application, we receive this as an request object and need to react to it. We love standards and want to make using X as simple as possible. That's why we build on top of the established PSR-7 standard (HTTP message interfaces). This standard defines common interfaces for HTTP request and response objects. If you've ever used PSR-7 before, you should immediately feel at home when using X. If you're new to PSR-7, don't worry. Here's everything you need to know to get started. \u2139\ufe0f A note about other PSR-7 implementations This documentation uses the Psr\\Http\\Message\\ServerRequestInterface for all examples. The actual class implementing this interface is an implementation detail that should not be relied upon. If you need to construct your own instance, we recommend using the React\\Http\\Message\\ServerRequest class because this comes bundled as part of our dependencies, but you may use any other implementation as long as it implements the same interface. Attributes \u00b6 You can access request attributes like this: $app->get('/user/{id}', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $id = $request->getAttribute('id'); return new React\\Http\\Message\\Response(200, [], \"Hello $id\"); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user/Alice Hello Alice These custom attributes are most commonly used when using URI placeholders from routing . Each placeholder will automatically be assigned to a matching request attribute. See also routing for more details. Additionally, these custom attributes can also be useful when passing additional information from a middleware handler to other handlers further down the chain (think authentication information). See also middleware for more details. JSON \u00b6 You can access JSON data from the HTTP request body like this: $app->post('/user', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $data = json_decode((string) $request->getBody()); $name = $data->name ?? 'anonymous'; return new React\\Http\\Message\\Response(200, [], \"Hello $name\"); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user --data '{\"name\":\"Alice\"}' Hello Alice Additionally, you may want to validate the Content-Type: application/json request header to be sure the client intended to send a JSON request body. This example returns a simple text response, you may also want to return a JSON response for common API usage. Form data \u00b6 You can access HTML form data from the HTTP request body like this: $app->post('/user', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $data = $request->getParsedBody(); $name = $data['name'] ?? 'Anonymous'; return new React\\Http\\Message\\Response(200, [], \"Hello $name\"); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user -d name = Alice Hello Alice This method returns a possibly nested array of form fields, very similar to PHP's $_POST superglobal. Uploads \u00b6 You can access any file uploads from HTML forms like this: $app->post('/user', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $files = $request->getUploadedFiles(); $name = isset($files['image']) ? $files['image']->getClientFilename() : 'x'; return new React\\Http\\Message\\Response(200, [], \"Uploaded $name\"); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user -F image = @~/Downloads/image.jpg Uploaded image.jpg This method returns a possibly nested array of files uploaded, very similar to PHP's $_FILES superglobal. Each file in this array implements the Psr\\Http\\Message\\UploadedFileInterface : $files = $request->getUploadedFiles(); $image = $files['image']; assert($image instanceof Psr\\Http\\Message\\UploadedFileInterface); $stream = $image->getStream(); assert($stream instanceof Psr\\Http\\Message\\StreamInterface); $contents = (string) $stream; $size = $image->getSize(); assert(is_int($size)); $name = $image->getClientFilename(); assert(is_string($name) || $name === null); $type = $image->getClientMediaType(); assert(is_string($type) || $name === null); \u2139\ufe0f Info Note that HTTP requests are currently limited to 64 KiB. Any uploads above this size will currently show up as an empty request body with no file uploads whatsoever. Headers \u00b6 You can access all HTTP request headers like this: $app->get('/user', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $agent = $request->getHeaderLine('User-Agent'); return new React\\Http\\Message\\Response(200, [], \"Hello $agent\"); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user -H 'User-Agent: FrameworkX/0' Hello FrameworkX/0 This example returns a simple text response with no additional response headers, you may also want to return response headers for common API usage. Parameters \u00b6 You can access server-side parameters like this: $app->get('/user', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $params = $request->getServerParams(); $ip = $params['REMOTE_ADDR'] ?? 'unknown'; return new React\\Http\\Message\\Response(200, [], \"Hello $ip\"); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user Hello 127 .0.0.1 This method returns an array of server-side parameters, very similar to PHP's $_SERVER superglobal. Note that available server parameters depend on the server software and version in use.","title":"Request"},{"location":"api/request/#request","text":"Whenever the client sends an HTTP request to our application, we receive this as an request object and need to react to it. We love standards and want to make using X as simple as possible. That's why we build on top of the established PSR-7 standard (HTTP message interfaces). This standard defines common interfaces for HTTP request and response objects. If you've ever used PSR-7 before, you should immediately feel at home when using X. If you're new to PSR-7, don't worry. Here's everything you need to know to get started. \u2139\ufe0f A note about other PSR-7 implementations This documentation uses the Psr\\Http\\Message\\ServerRequestInterface for all examples. The actual class implementing this interface is an implementation detail that should not be relied upon. If you need to construct your own instance, we recommend using the React\\Http\\Message\\ServerRequest class because this comes bundled as part of our dependencies, but you may use any other implementation as long as it implements the same interface.","title":"Request"},{"location":"api/request/#attributes","text":"You can access request attributes like this: $app->get('/user/{id}', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $id = $request->getAttribute('id'); return new React\\Http\\Message\\Response(200, [], \"Hello $id\"); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user/Alice Hello Alice These custom attributes are most commonly used when using URI placeholders from routing . Each placeholder will automatically be assigned to a matching request attribute. See also routing for more details. Additionally, these custom attributes can also be useful when passing additional information from a middleware handler to other handlers further down the chain (think authentication information). See also middleware for more details.","title":"Attributes"},{"location":"api/request/#json","text":"You can access JSON data from the HTTP request body like this: $app->post('/user', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $data = json_decode((string) $request->getBody()); $name = $data->name ?? 'anonymous'; return new React\\Http\\Message\\Response(200, [], \"Hello $name\"); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user --data '{\"name\":\"Alice\"}' Hello Alice Additionally, you may want to validate the Content-Type: application/json request header to be sure the client intended to send a JSON request body. This example returns a simple text response, you may also want to return a JSON response for common API usage.","title":"JSON"},{"location":"api/request/#form-data","text":"You can access HTML form data from the HTTP request body like this: $app->post('/user', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $data = $request->getParsedBody(); $name = $data['name'] ?? 'Anonymous'; return new React\\Http\\Message\\Response(200, [], \"Hello $name\"); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user -d name = Alice Hello Alice This method returns a possibly nested array of form fields, very similar to PHP's $_POST superglobal.","title":"Form data"},{"location":"api/request/#uploads","text":"You can access any file uploads from HTML forms like this: $app->post('/user', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $files = $request->getUploadedFiles(); $name = isset($files['image']) ? $files['image']->getClientFilename() : 'x'; return new React\\Http\\Message\\Response(200, [], \"Uploaded $name\"); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user -F image = @~/Downloads/image.jpg Uploaded image.jpg This method returns a possibly nested array of files uploaded, very similar to PHP's $_FILES superglobal. Each file in this array implements the Psr\\Http\\Message\\UploadedFileInterface : $files = $request->getUploadedFiles(); $image = $files['image']; assert($image instanceof Psr\\Http\\Message\\UploadedFileInterface); $stream = $image->getStream(); assert($stream instanceof Psr\\Http\\Message\\StreamInterface); $contents = (string) $stream; $size = $image->getSize(); assert(is_int($size)); $name = $image->getClientFilename(); assert(is_string($name) || $name === null); $type = $image->getClientMediaType(); assert(is_string($type) || $name === null); \u2139\ufe0f Info Note that HTTP requests are currently limited to 64 KiB. Any uploads above this size will currently show up as an empty request body with no file uploads whatsoever.","title":"Uploads"},{"location":"api/request/#headers","text":"You can access all HTTP request headers like this: $app->get('/user', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $agent = $request->getHeaderLine('User-Agent'); return new React\\Http\\Message\\Response(200, [], \"Hello $agent\"); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user -H 'User-Agent: FrameworkX/0' Hello FrameworkX/0 This example returns a simple text response with no additional response headers, you may also want to return response headers for common API usage.","title":"Headers"},{"location":"api/request/#parameters","text":"You can access server-side parameters like this: $app->get('/user', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $params = $request->getServerParams(); $ip = $params['REMOTE_ADDR'] ?? 'unknown'; return new React\\Http\\Message\\Response(200, [], \"Hello $ip\"); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user Hello 127 .0.0.1 This method returns an array of server-side parameters, very similar to PHP's $_SERVER superglobal. Note that available server parameters depend on the server software and version in use.","title":"Parameters"},{"location":"api/response/","text":"Response \u00b6 Whenever the client sends an HTTP request to our application, we need to send back an HTTP response message. We love standards and want to make using X as simple as possible. That's why we build on top of the established PSR-7 standard (HTTP message interfaces). This standard defines common interfaces for HTTP request and response objects. If you've ever used PSR-7 before, you should immediately feel at home when using X. If you're new to PSR-7, don't worry. Here's everything you need to know to get started. \u2139\ufe0f A note about other PSR-7 implementations All of the examples in this documentation use the React\\Http\\Message\\Response class because this comes bundled as part of our dependencies. If you have more specific requirements or want to integrate this with an existing piece of code, you can use any response implementation as long as it implements the Psr\\Http\\Message\\ResponseInterface . JSON \u00b6 You can send JSON data as an HTTP response body like this: $app->get('/user', function () { $data = [ [ 'name' => 'Alice' ], [ 'name' => 'Bob' ] ]; return new React\\Http\\Message\\Response( 200, ['Content-Type' => 'application/json'], json_encode($data) ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user [{ \"name\" : \"Alice\" } , { \"name\" : \"Bob\" }] If you want to return pretty-printed JSON, all you need to do is passing the correct flags when encoding: $app->get('/user', function () { $data = [ [ 'name' => 'Alice' ], [ 'name' => 'Bob' ] ]; return new React\\Http\\Message\\Response( 200, ['Content-Type' => 'application/json'], json_encode( $data, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE ) ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user [ { \"name\" : \"Alice\" } , { \"name\" : \"Bob\" } ] This example returns a simple JSON response from some static data. In real-world applications, you may want to load this from a database . For common API usage, you may also want to receive a JSON request . HTML \u00b6 You can send HTML data as an HTTP response body like this: $app->get('/user', function () { $html = <<<HTML <h1>Hello Alice</h1> HTML; return new React\\Http\\Message\\Response( 200, ['Content-Type' => 'text/html; charset=utf-8'], $html ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user <h1>Hello Alice</h1> This example returns a simple HTML response from some static data. In real-world applications, you may want to load this from a database and perhaps use templates to render your HTML. Status Codes \u00b6 You can assign status codes like this: $app->get('/user/{id}', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $id = $request->getAttribute('id'); if ($id === 'admin') { return new React\\Http\\Message\\Response( 403, [], 'Forbidden' ); } return new React\\Http\\Message\\Response( 200, [], \"Hello $id\" ); }); An HTTP request can be sent like this: $ curl -I http://localhost:8080/user/Alice HTTP/1.1 200 OK \u2026 $ curl -I http://localhost:8080/user/admin HTTP/1.1 403 Forbidden \u2026 Each HTTP response message contains a status code that describes whether the HTTP request has been successfully completed. Here's a list of the most common HTTP status codes: 200 OK 301 Permanent Redirect 302 Found (previously 302 Temporary Redirect ) 304 Not Modified (see HTTP caching below) 403 Forbidden 404 Not Found 500 Internal Server Error \u2026 See list of HTTP status codes for more details. Headers \u00b6 You can assign HTTP response headers like this: $app->get('/user', function () { return new React\\Http\\Message\\Response( 200, ['Content-Type' => 'text/plain; charset=utf-8'], \"Hello w\u00f6rld\" ); }); An HTTP request can be sent like this: $ curl -I http://localhost:8080/user HTTP/1.1 200 OK Content-Type: text/plain ; charset = utf-8 \u2026 Each HTTP response message can contain an arbitrary number of response headers. You can pass these headers as an associative array to the response object. Additionally, the application will automatically include default headers required by the HTTP protocol. It's not recommended to mess with these default headers unless you're sure you know what you're doing. HTTP caching \u00b6 HTTP caching can be used to significantly improve the performance of web applications by reusing previously fetched resources. HTTP caching is a whole topic on its own, so this section only aims to give a basic overview of how you can leverage HTTP caches with X. For a more in-depth overview, we highly recommend MDN . HTTP supports caching for certain requests by default. In any but the most basic use cases, it's often a good idea to explicitly specify HTTP caching headers as part of the HTTP response to have more control over the freshness lifetime and revalidation behavior. Cache-Control \u00b6 The Cache-Control response header can be used to control caching of responses by browsers and shared caches such as proxies and CDNs. In its most basic form, you can use this response header to control the lifetime of a cached response like this: <?php // \u2026 $app -> get ( '/user' , function () { $html = <<< HTML <h1>Hello Alice</h1> HTML ; return new Response ( 200 , [ 'Content-Type' => 'text/html; charset=utf-8' , 'Cache-Control' => 'max-age=3600' , ], $html ); }); An HTTP request can be sent like this: $ curl -I http://localhost:8080/user HTTP/1.1 200 OK Cache-Control: max-age = 3600 \u2026 ETag \u00b6 The ETag response header can be used for conditional requests. This ensures the response body only needs to be transferred when it actually changes. For instance, you can build a hash (or some other arbitrary identifier) for your contents and check if it matches the incoming If-None-Match request header for subsequent requests. If both values match, you can send a 304 Not Modified response and omit the response body like this: <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { // example body, would usually come from some kind of database $html = <<< HTML <h1>Hello Alice</h1> HTML ; $etag = '\"' . sha1 ( $html ) . '\"' ; if ( $request -> getHeaderLine ( 'If-None-Match' ) === $etag ) { return new Response ( 304 , [ 'Cache-Control' => 'max-age=0, must-revalidate' , 'ETag' => $etag ] ); } return new Response ( 200 , [ 'Content-Type' => 'text/html; charset=utf-8' , 'Cache-Control' => 'max-age=0, must-revalidate' , 'ETag' => $etag ], $html ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user <h1>Hello Alice</h1> $ curl -I http://localhost:8080/user -H 'If-None-Match: \"87637b595ed5b32934c011dc6b33afb43f598865\"' HTTP/1.1 304 Not Modified Cache-Control: max-age = 0 , must-revalidate ETag: \"87637b595ed5b32934c011dc6b33afb43f598865\" \u2026 Last-Modified \u00b6 The Last-Modified response header can be used to signal when a response was last modified. Among others, this can be used to ensure the response body only needs to be transferred when it changes. For instance, you can store a timestamp or datetime for your contents and check if it matches the incoming If-Modified-Since request header for subsequent requests. If both values match, you can send a 304 Not Modified response and omit the response body like this: <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { // example date and body, would usually come from some kind of database $date = new DateTimeImmutable ( '2021-11-06 13:31:04' , new DateTimeZone ( 'Europe/Berlin' ) ); $html = <<< HTML <h1>Hello Alice</h1> HTML ; $modified = $date -> setTimezone ( new DateTimeZone ( 'UTC' )) -> format ( DATE_RFC7231 ); if ( $request -> getHeaderLine ( 'If-Modified-Since' ) === $modified ) { return new Response ( 304 , [ 'Cache-Control' => 'max-age=0, must-revalidate' , 'Last-Modified' => $modified ] ); } return new Response ( 200 , [ 'Content-Type' => 'text/html; charset=utf-8' , 'Cache-Control' => 'max-age=0, must-revalidate' , 'Last-Modified' => $modified ], $html ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user <h1>Hello Alice</h1> $ curl -I http://localhost:8080/user -H 'If-Modified-Since: Sat, 06 Nov 2021 12:31:04 GMT' HTTP/1.1 304 Not Modified Cache-Control: max-age = 0 , must-revalidate Last-Modified: Sat, 06 Nov 2021 12 :31:04 GMT \u2026 \u2139\ufe0f Working with dates For use in HTTP, you may format any date in the GMT/UTC timezone using the DATE_RFC7231 (PHP 7.1.5+) constant as given above. If you don't know the modification date for your response or don't want to expose this information, you may want to use ETag headers from the previous section instead. Output buffering \u00b6 PHP provides a number of functions that write directly to the output buffer instead of returning values: echo , print , printf() , vprintf() , etc. var_dump() , var_export() , print_r() , etc. readfile() , fpassthru() , passthru() , etc. \u2026 These functions can also be used in X, but do require some special care because we want to redirect this output to be part of an HTTP response instead. You can start a temporary output buffer using ob_start() to catch any output and return it as a response body like this: <?php // \u2026 $app -> get ( '/dump' , function () { ob_start (); echo \"Hello \\n \" ; var_dump ( 42 ); $body = ob_get_clean (); return new React\\Http\\Message\\Response ( 200 , [ 'Content-Type' => 'text/plain; charset=utf-8' ], $body ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/dump Hello int ( 42 ) \u2139\ufe0f A word of caution Special care should be taken if the code in question is deeply nested with multiple return conditions or may throw an Exception . As a rule of thumb, output buffering should only be used as a last resort and directly working with string values is usually preferable. For instance, print_r() , var_export() and others accept optional boolean flags to return the value instead of printing to the output buffer. In many other cases, PHP also provides alternative functions that directly return string values instead of writing to the output buffer. For instance, instead of using printf() , you may want to use sprintf() . Internal Server Error \u00b6 Each controller function needs to return a response object in order to send an HTTP response message. If the controller functions throws an Exception (or Throwable ) or any other type, the HTTP request will automatically be rejected with a 500 Internal Server Error HTTP error response: $app->get('/user', function () { throw new BadMethodCallException(); }); An HTTP request can be sent like this: $ curl -I http://localhost:8080/user HTTP/1.1 500 Internal Server Error \u2026 This error message contains only few details to the client to avoid leaking internal information. If you want to implement custom error handling, you're recommended to either catch any exceptions your own or use a middleware handler to catch any exceptions in your application.","title":"Response"},{"location":"api/response/#response","text":"Whenever the client sends an HTTP request to our application, we need to send back an HTTP response message. We love standards and want to make using X as simple as possible. That's why we build on top of the established PSR-7 standard (HTTP message interfaces). This standard defines common interfaces for HTTP request and response objects. If you've ever used PSR-7 before, you should immediately feel at home when using X. If you're new to PSR-7, don't worry. Here's everything you need to know to get started. \u2139\ufe0f A note about other PSR-7 implementations All of the examples in this documentation use the React\\Http\\Message\\Response class because this comes bundled as part of our dependencies. If you have more specific requirements or want to integrate this with an existing piece of code, you can use any response implementation as long as it implements the Psr\\Http\\Message\\ResponseInterface .","title":"Response"},{"location":"api/response/#json","text":"You can send JSON data as an HTTP response body like this: $app->get('/user', function () { $data = [ [ 'name' => 'Alice' ], [ 'name' => 'Bob' ] ]; return new React\\Http\\Message\\Response( 200, ['Content-Type' => 'application/json'], json_encode($data) ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user [{ \"name\" : \"Alice\" } , { \"name\" : \"Bob\" }] If you want to return pretty-printed JSON, all you need to do is passing the correct flags when encoding: $app->get('/user', function () { $data = [ [ 'name' => 'Alice' ], [ 'name' => 'Bob' ] ]; return new React\\Http\\Message\\Response( 200, ['Content-Type' => 'application/json'], json_encode( $data, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE ) ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user [ { \"name\" : \"Alice\" } , { \"name\" : \"Bob\" } ] This example returns a simple JSON response from some static data. In real-world applications, you may want to load this from a database . For common API usage, you may also want to receive a JSON request .","title":"JSON"},{"location":"api/response/#html","text":"You can send HTML data as an HTTP response body like this: $app->get('/user', function () { $html = <<<HTML <h1>Hello Alice</h1> HTML; return new React\\Http\\Message\\Response( 200, ['Content-Type' => 'text/html; charset=utf-8'], $html ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user <h1>Hello Alice</h1> This example returns a simple HTML response from some static data. In real-world applications, you may want to load this from a database and perhaps use templates to render your HTML.","title":"HTML"},{"location":"api/response/#status-codes","text":"You can assign status codes like this: $app->get('/user/{id}', function (Psr\\Http\\Message\\ServerRequestInterface $request) { $id = $request->getAttribute('id'); if ($id === 'admin') { return new React\\Http\\Message\\Response( 403, [], 'Forbidden' ); } return new React\\Http\\Message\\Response( 200, [], \"Hello $id\" ); }); An HTTP request can be sent like this: $ curl -I http://localhost:8080/user/Alice HTTP/1.1 200 OK \u2026 $ curl -I http://localhost:8080/user/admin HTTP/1.1 403 Forbidden \u2026 Each HTTP response message contains a status code that describes whether the HTTP request has been successfully completed. Here's a list of the most common HTTP status codes: 200 OK 301 Permanent Redirect 302 Found (previously 302 Temporary Redirect ) 304 Not Modified (see HTTP caching below) 403 Forbidden 404 Not Found 500 Internal Server Error \u2026 See list of HTTP status codes for more details.","title":"Status Codes"},{"location":"api/response/#headers","text":"You can assign HTTP response headers like this: $app->get('/user', function () { return new React\\Http\\Message\\Response( 200, ['Content-Type' => 'text/plain; charset=utf-8'], \"Hello w\u00f6rld\" ); }); An HTTP request can be sent like this: $ curl -I http://localhost:8080/user HTTP/1.1 200 OK Content-Type: text/plain ; charset = utf-8 \u2026 Each HTTP response message can contain an arbitrary number of response headers. You can pass these headers as an associative array to the response object. Additionally, the application will automatically include default headers required by the HTTP protocol. It's not recommended to mess with these default headers unless you're sure you know what you're doing.","title":"Headers"},{"location":"api/response/#http-caching","text":"HTTP caching can be used to significantly improve the performance of web applications by reusing previously fetched resources. HTTP caching is a whole topic on its own, so this section only aims to give a basic overview of how you can leverage HTTP caches with X. For a more in-depth overview, we highly recommend MDN . HTTP supports caching for certain requests by default. In any but the most basic use cases, it's often a good idea to explicitly specify HTTP caching headers as part of the HTTP response to have more control over the freshness lifetime and revalidation behavior.","title":"HTTP caching"},{"location":"api/response/#cache-control","text":"The Cache-Control response header can be used to control caching of responses by browsers and shared caches such as proxies and CDNs. In its most basic form, you can use this response header to control the lifetime of a cached response like this: <?php // \u2026 $app -> get ( '/user' , function () { $html = <<< HTML <h1>Hello Alice</h1> HTML ; return new Response ( 200 , [ 'Content-Type' => 'text/html; charset=utf-8' , 'Cache-Control' => 'max-age=3600' , ], $html ); }); An HTTP request can be sent like this: $ curl -I http://localhost:8080/user HTTP/1.1 200 OK Cache-Control: max-age = 3600 \u2026","title":"Cache-Control"},{"location":"api/response/#etag","text":"The ETag response header can be used for conditional requests. This ensures the response body only needs to be transferred when it actually changes. For instance, you can build a hash (or some other arbitrary identifier) for your contents and check if it matches the incoming If-None-Match request header for subsequent requests. If both values match, you can send a 304 Not Modified response and omit the response body like this: <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { // example body, would usually come from some kind of database $html = <<< HTML <h1>Hello Alice</h1> HTML ; $etag = '\"' . sha1 ( $html ) . '\"' ; if ( $request -> getHeaderLine ( 'If-None-Match' ) === $etag ) { return new Response ( 304 , [ 'Cache-Control' => 'max-age=0, must-revalidate' , 'ETag' => $etag ] ); } return new Response ( 200 , [ 'Content-Type' => 'text/html; charset=utf-8' , 'Cache-Control' => 'max-age=0, must-revalidate' , 'ETag' => $etag ], $html ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user <h1>Hello Alice</h1> $ curl -I http://localhost:8080/user -H 'If-None-Match: \"87637b595ed5b32934c011dc6b33afb43f598865\"' HTTP/1.1 304 Not Modified Cache-Control: max-age = 0 , must-revalidate ETag: \"87637b595ed5b32934c011dc6b33afb43f598865\" \u2026","title":"ETag"},{"location":"api/response/#last-modified","text":"The Last-Modified response header can be used to signal when a response was last modified. Among others, this can be used to ensure the response body only needs to be transferred when it changes. For instance, you can store a timestamp or datetime for your contents and check if it matches the incoming If-Modified-Since request header for subsequent requests. If both values match, you can send a 304 Not Modified response and omit the response body like this: <?php // \u2026 $app -> get ( '/user' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { // example date and body, would usually come from some kind of database $date = new DateTimeImmutable ( '2021-11-06 13:31:04' , new DateTimeZone ( 'Europe/Berlin' ) ); $html = <<< HTML <h1>Hello Alice</h1> HTML ; $modified = $date -> setTimezone ( new DateTimeZone ( 'UTC' )) -> format ( DATE_RFC7231 ); if ( $request -> getHeaderLine ( 'If-Modified-Since' ) === $modified ) { return new Response ( 304 , [ 'Cache-Control' => 'max-age=0, must-revalidate' , 'Last-Modified' => $modified ] ); } return new Response ( 200 , [ 'Content-Type' => 'text/html; charset=utf-8' , 'Cache-Control' => 'max-age=0, must-revalidate' , 'Last-Modified' => $modified ], $html ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/user <h1>Hello Alice</h1> $ curl -I http://localhost:8080/user -H 'If-Modified-Since: Sat, 06 Nov 2021 12:31:04 GMT' HTTP/1.1 304 Not Modified Cache-Control: max-age = 0 , must-revalidate Last-Modified: Sat, 06 Nov 2021 12 :31:04 GMT \u2026 \u2139\ufe0f Working with dates For use in HTTP, you may format any date in the GMT/UTC timezone using the DATE_RFC7231 (PHP 7.1.5+) constant as given above. If you don't know the modification date for your response or don't want to expose this information, you may want to use ETag headers from the previous section instead.","title":"Last-Modified"},{"location":"api/response/#output-buffering","text":"PHP provides a number of functions that write directly to the output buffer instead of returning values: echo , print , printf() , vprintf() , etc. var_dump() , var_export() , print_r() , etc. readfile() , fpassthru() , passthru() , etc. \u2026 These functions can also be used in X, but do require some special care because we want to redirect this output to be part of an HTTP response instead. You can start a temporary output buffer using ob_start() to catch any output and return it as a response body like this: <?php // \u2026 $app -> get ( '/dump' , function () { ob_start (); echo \"Hello \\n \" ; var_dump ( 42 ); $body = ob_get_clean (); return new React\\Http\\Message\\Response ( 200 , [ 'Content-Type' => 'text/plain; charset=utf-8' ], $body ); }); An HTTP request can be sent like this: $ curl http://localhost:8080/dump Hello int ( 42 ) \u2139\ufe0f A word of caution Special care should be taken if the code in question is deeply nested with multiple return conditions or may throw an Exception . As a rule of thumb, output buffering should only be used as a last resort and directly working with string values is usually preferable. For instance, print_r() , var_export() and others accept optional boolean flags to return the value instead of printing to the output buffer. In many other cases, PHP also provides alternative functions that directly return string values instead of writing to the output buffer. For instance, instead of using printf() , you may want to use sprintf() .","title":"Output buffering"},{"location":"api/response/#internal-server-error","text":"Each controller function needs to return a response object in order to send an HTTP response message. If the controller functions throws an Exception (or Throwable ) or any other type, the HTTP request will automatically be rejected with a 500 Internal Server Error HTTP error response: $app->get('/user', function () { throw new BadMethodCallException(); }); An HTTP request can be sent like this: $ curl -I http://localhost:8080/user HTTP/1.1 500 Internal Server Error \u2026 This error message contains only few details to the client to avoid leaking internal information. If you want to implement custom error handling, you're recommended to either catch any exceptions your own or use a middleware handler to catch any exceptions in your application.","title":"Internal Server Error"},{"location":"async/child-processes/","text":"Parallel processing with child processes \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Avoid blocking by moving blocking implementation to child process Child process I/O for communication Multithreading, but isolated processes See reactphp/child-process for underlying APIs See clue/reactphp-pq for higher-level API to automatically wrap blocking functions in an async child process and turn blocking functions into non-blocking promises","title":"Child processes"},{"location":"async/child-processes/#parallel-processing-with-child-processes","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Avoid blocking by moving blocking implementation to child process Child process I/O for communication Multithreading, but isolated processes See reactphp/child-process for underlying APIs See clue/reactphp-pq for higher-level API to automatically wrap blocking functions in an async child process and turn blocking functions into non-blocking promises","title":"Parallel processing with child processes"},{"location":"async/coroutines/","text":"Coroutines \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Promises can be hard due to nested callbacks X provides Generator-based coroutines Synchronous code structure, yet asynchronous execution Generators can be a bit harder to understand, see Fibers for future PHP 8.1 API. Coroutines $app->get('/book/{id:\\d+}', function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($db, $twig) { $row = yield $db->query( 'SELECT * FROM books WHERE ID=?', [$request->getAttribute('id')] ); $html = $twig->render('book.twig', $row); return new React\\Http\\Message\\Response( 200, [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); }); Synchronous (for comparison) $app->get('/book/{id:\\d+}', function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($db, $twig) { $row = $db->query( 'SELECT * FROM books WHERE ID=?', [$request->getAttribute('id')] ); $html = $twig->render('book.twig', $row); return new React\\Http\\Message\\Response( 200, [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); }); This example highlights how async PHP can look pretty much like a normal, synchronous code structure. The only difference is in how the yield statement can be used to await an async promise . In order for this to work, this example assumes an async database that uses promises . Coroutines vs. Promises? \u00b6 We're the first to admit that promises can look more complicated, so why offer both? In fact, both styles exist for a reason. Promises are used to represent an eventual return value. Even when using coroutines, this does not change how the underlying APIs (such as a database) still have to return promises. If you want to consume a promise, you get to choose between the promise-based API and using coroutines: Coroutines $app->get('/book/{id:\\d+}', function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($db, $twig) { $row = yield $db->query( 'SELECT * FROM books WHERE ID=?', [$request->getAttribute('id')] ); $html = $twig->render('book.twig', $row); return new React\\Http\\Message\\Response( 200, [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); }); Promises (for comparison) $app->get('/book/{id:\\d+}', function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($db, $twig) { return $db->query( 'SELECT * FROM books WHERE ID=?', [$request->getAttribute('id')] )->then(function (array $row) use ($twig) { $html = $twig->render('book.twig', $row); return new React\\Http\\Message\\Response( 200, [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); }); }); This example highlights how using coroutines in your controllers can look somewhat easier because coroutines hide some of the complexity of async APIs. X has a strong focus on simple APIs, so we also support coroutines. For this reason, some people may prefer the coroutine-style async execution model in their controllers. At the same time, it should be pointed out that coroutines build on top of promises. This means that having a good understanding of how async APIs using promises work can be somewhat beneficial. Indeed this means that code flow could even be harder to understand for some people, especially if you're already used to async execution models using promise-based APIs. Which style is better? We like choice. Feel free to use whatever style best works for you. \ud83d\udd2e Future fiber support in PHP 8.1 In the future, PHP 8.1 will provide native support for fibers . Once fibers become mainstream, there would be little reason to use Generator-based coroutines anymore. While fibers will help to avoid using promises for many common use cases, promises will still be useful for concurrent execution. See fibers for more details.","title":"Coroutines"},{"location":"async/coroutines/#coroutines","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Promises can be hard due to nested callbacks X provides Generator-based coroutines Synchronous code structure, yet asynchronous execution Generators can be a bit harder to understand, see Fibers for future PHP 8.1 API. Coroutines $app->get('/book/{id:\\d+}', function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($db, $twig) { $row = yield $db->query( 'SELECT * FROM books WHERE ID=?', [$request->getAttribute('id')] ); $html = $twig->render('book.twig', $row); return new React\\Http\\Message\\Response( 200, [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); }); Synchronous (for comparison) $app->get('/book/{id:\\d+}', function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($db, $twig) { $row = $db->query( 'SELECT * FROM books WHERE ID=?', [$request->getAttribute('id')] ); $html = $twig->render('book.twig', $row); return new React\\Http\\Message\\Response( 200, [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); }); This example highlights how async PHP can look pretty much like a normal, synchronous code structure. The only difference is in how the yield statement can be used to await an async promise . In order for this to work, this example assumes an async database that uses promises .","title":"Coroutines"},{"location":"async/coroutines/#coroutines-vs-promises","text":"We're the first to admit that promises can look more complicated, so why offer both? In fact, both styles exist for a reason. Promises are used to represent an eventual return value. Even when using coroutines, this does not change how the underlying APIs (such as a database) still have to return promises. If you want to consume a promise, you get to choose between the promise-based API and using coroutines: Coroutines $app->get('/book/{id:\\d+}', function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($db, $twig) { $row = yield $db->query( 'SELECT * FROM books WHERE ID=?', [$request->getAttribute('id')] ); $html = $twig->render('book.twig', $row); return new React\\Http\\Message\\Response( 200, [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); }); Promises (for comparison) $app->get('/book/{id:\\d+}', function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($db, $twig) { return $db->query( 'SELECT * FROM books WHERE ID=?', [$request->getAttribute('id')] )->then(function (array $row) use ($twig) { $html = $twig->render('book.twig', $row); return new React\\Http\\Message\\Response( 200, [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); }); }); This example highlights how using coroutines in your controllers can look somewhat easier because coroutines hide some of the complexity of async APIs. X has a strong focus on simple APIs, so we also support coroutines. For this reason, some people may prefer the coroutine-style async execution model in their controllers. At the same time, it should be pointed out that coroutines build on top of promises. This means that having a good understanding of how async APIs using promises work can be somewhat beneficial. Indeed this means that code flow could even be harder to understand for some people, especially if you're already used to async execution models using promise-based APIs. Which style is better? We like choice. Feel free to use whatever style best works for you. \ud83d\udd2e Future fiber support in PHP 8.1 In the future, PHP 8.1 will provide native support for fibers . Once fibers become mainstream, there would be little reason to use Generator-based coroutines anymore. While fibers will help to avoid using promises for many common use cases, promises will still be useful for concurrent execution. See fibers for more details.","title":"Coroutines vs. Promises?"},{"location":"async/fibers/","text":"Fibers \u00b6 \u26a0\ufe0f Feature preview This is a feature preview, i.e. it might not have made it into the current beta. Give feedback to help us prioritize. You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Hot topic for PHP 8.1 Async APIs that look just like their synchronous counterparts Much easier to integrate, possibly larger ecosystem in future Requires PHP 8.1 (November 2021), adoption will take time Promises still required for concurrent execution Promises and Coroutines work just fine until ecosystem matures See blog post","title":"Fibers"},{"location":"async/fibers/#fibers","text":"\u26a0\ufe0f Feature preview This is a feature preview, i.e. it might not have made it into the current beta. Give feedback to help us prioritize. You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Hot topic for PHP 8.1 Async APIs that look just like their synchronous counterparts Much easier to integrate, possibly larger ecosystem in future Requires PHP 8.1 (November 2021), adoption will take time Promises still required for concurrent execution Promises and Coroutines work just fine until ecosystem matures See blog post","title":"Fibers"},{"location":"async/promises/","text":"Promises \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Avoid blocking ( databases , filesystem , etc.) Deferred execution Concurrent execution more efficient than multithreading Avoid blocking by moving blocking implementation to child process Promise-based $app->get('/book/{id:\\d+}', function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($db, $twig) { return $db->query( 'SELECT * FROM books WHERE ID=?', [$request->getAttribute('id')] )->then(function (array $row) use ($twig) { $html = $twig->render('book.twig', $row); return new React\\Http\\Message\\Response( 200, [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); }); }); Synchronous (for comparision) $app->get('/book/{id:\\d+}', function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($db, $twig) { $row = $db->query( 'SELECT * FROM books WHERE ID=?', [$request->getAttribute('id')] ); $html = $twig->render('book.twig', $row); return new React\\Http\\Message\\Response( 200, [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); }); In this example, we assume an async database adapter that returns a promise which fulfills with some data instead of directly returning data. The major feature is that this means that anything that takes some time will no longer block the entire execution. These non-blocking operations are especially benefitial for anything that incurs some kind of I/O , such as database queries , HTTP API requests, filesystem access and much more. If you want to learn more about the promise API, see also reactphp/promise . Admittedly, this example also showcases how async PHP can look slightly more complicated than a normal, synchronous code structure. Because we realize this API can be somewhat harder in some cases, we also support coroutines (and in upcoming PHP 8.1 will also support fibers ).","title":"Promises"},{"location":"async/promises/#promises","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Avoid blocking ( databases , filesystem , etc.) Deferred execution Concurrent execution more efficient than multithreading Avoid blocking by moving blocking implementation to child process Promise-based $app->get('/book/{id:\\d+}', function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($db, $twig) { return $db->query( 'SELECT * FROM books WHERE ID=?', [$request->getAttribute('id')] )->then(function (array $row) use ($twig) { $html = $twig->render('book.twig', $row); return new React\\Http\\Message\\Response( 200, [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); }); }); Synchronous (for comparision) $app->get('/book/{id:\\d+}', function (Psr\\Http\\Message\\ServerRequestInterface $request) use ($db, $twig) { $row = $db->query( 'SELECT * FROM books WHERE ID=?', [$request->getAttribute('id')] ); $html = $twig->render('book.twig', $row); return new React\\Http\\Message\\Response( 200, [ 'Content-Type' => 'text/html; charset=utf-8' ], $html ); }); In this example, we assume an async database adapter that returns a promise which fulfills with some data instead of directly returning data. The major feature is that this means that anything that takes some time will no longer block the entire execution. These non-blocking operations are especially benefitial for anything that incurs some kind of I/O , such as database queries , HTTP API requests, filesystem access and much more. If you want to learn more about the promise API, see also reactphp/promise . Admittedly, this example also showcases how async PHP can look slightly more complicated than a normal, synchronous code structure. Because we realize this API can be somewhat harder in some cases, we also support coroutines (and in upcoming PHP 8.1 will also support fibers ).","title":"Promises"},{"location":"async/streaming/","text":"Streaming \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Processing large amounts of data or when data arrives at future time. Streaming downloads \u00b6 Efficient processing of large files without keeping contents in memory Similar for video streaming, but not scope of this project EventSource \u00b6 HTML5 Server-Sent Events (SSE) aka. EventSource supported out-of-the-box Live streaming, live data, realtime communication WebSockets \u00b6 HTML5 WebSockets integration supported with Ratchet See also EventSource as alternative Bidirectional communication","title":"Streaming"},{"location":"async/streaming/#streaming","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Processing large amounts of data or when data arrives at future time.","title":"Streaming"},{"location":"async/streaming/#streaming-downloads","text":"Efficient processing of large files without keeping contents in memory Similar for video streaming, but not scope of this project","title":"Streaming downloads"},{"location":"async/streaming/#eventsource","text":"HTML5 Server-Sent Events (SSE) aka. EventSource supported out-of-the-box Live streaming, live data, realtime communication","title":"EventSource"},{"location":"async/streaming/#websockets","text":"HTML5 WebSockets integration supported with Ratchet See also EventSource as alternative Bidirectional communication","title":"WebSockets"},{"location":"best-practices/controllers/","text":"Controller classes to structure your app \u00b6 When starting with X, it's often easiest to start with simple closure definitions like suggested in the quickstart guide . As a next step, let's take a look at how this structure can be improved with controller classes. This is especially useful once you leave the prototyping phase and want to find the best structure for a production-ready setup. To get started, let's take a look at the following simple closure definitions: # app.php <?php require __DIR__ . '/vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , function () { return new React\\Http\\Message\\Response ( 200 , [], \"Hello w\u00f6rld! \\n \" ); }); $app -> get ( '/users/{name}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { return new React\\Http\\Message\\Response ( 200 , [], \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); }); $app -> run (); While easy to get started, it's also easy to see how this will get out of hand for more complex business domains when you have more than a couple of routes registered. For real-world applications, we highly recommend structuring your application into invidividual controller classes. This way, we can break up the above definition into three even simpler files: # app.php <?php require __DIR__ . '/vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , new Acme\\Todo\\HelloController ()); $app -> get ( '/users/{name}' , new Acme\\Todo\\UserController ()); $app -> run (); # src/HelloController.php <?php namespace Acme\\Todo ; use React\\Http\\Message\\Response ; class HelloController { public function __invoke () { return new Response ( 200 , [], \"Hello w\u00f6rld! \\n \" ); } } # src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { return new Response ( 200 , [], \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); } } Doesn't look too complex, right? Now, we only need to tell Composer's autoloader about our vendor namespace Acme\\Todo in the src/ folder. Make sure to include the following lines in your composer.json file: { \"autoload\" : { \"psr-4\" : { \"Acme\\\\Todo\\\\\" : \"src/\" } } } When we're doing this the first time, we have to update Composer's generated autoloader classes: $ composer dump-autoload \u2139\ufe0f New to Composer? Don't worry, that's a one-time setup only. If you're used to working with Composer, this shouldn't be too surprising. If this sounds new to you, rest assured this is the only time you have to worry about this, new classes can simply be added without having to run Composer again. Again, let's see our web application still works by using your favorite webbrowser or command line tool: $ curl http://localhost:8080/ Hello w\u00f6rld! If everything works as expected, we can continue with writing our first tests to automate this.","title":"Controller classes"},{"location":"best-practices/controllers/#controller-classes-to-structure-your-app","text":"When starting with X, it's often easiest to start with simple closure definitions like suggested in the quickstart guide . As a next step, let's take a look at how this structure can be improved with controller classes. This is especially useful once you leave the prototyping phase and want to find the best structure for a production-ready setup. To get started, let's take a look at the following simple closure definitions: # app.php <?php require __DIR__ . '/vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , function () { return new React\\Http\\Message\\Response ( 200 , [], \"Hello w\u00f6rld! \\n \" ); }); $app -> get ( '/users/{name}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { return new React\\Http\\Message\\Response ( 200 , [], \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); }); $app -> run (); While easy to get started, it's also easy to see how this will get out of hand for more complex business domains when you have more than a couple of routes registered. For real-world applications, we highly recommend structuring your application into invidividual controller classes. This way, we can break up the above definition into three even simpler files: # app.php <?php require __DIR__ . '/vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , new Acme\\Todo\\HelloController ()); $app -> get ( '/users/{name}' , new Acme\\Todo\\UserController ()); $app -> run (); # src/HelloController.php <?php namespace Acme\\Todo ; use React\\Http\\Message\\Response ; class HelloController { public function __invoke () { return new Response ( 200 , [], \"Hello w\u00f6rld! \\n \" ); } } # src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { return new Response ( 200 , [], \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); } } Doesn't look too complex, right? Now, we only need to tell Composer's autoloader about our vendor namespace Acme\\Todo in the src/ folder. Make sure to include the following lines in your composer.json file: { \"autoload\" : { \"psr-4\" : { \"Acme\\\\Todo\\\\\" : \"src/\" } } } When we're doing this the first time, we have to update Composer's generated autoloader classes: $ composer dump-autoload \u2139\ufe0f New to Composer? Don't worry, that's a one-time setup only. If you're used to working with Composer, this shouldn't be too surprising. If this sounds new to you, rest assured this is the only time you have to worry about this, new classes can simply be added without having to run Composer again. Again, let's see our web application still works by using your favorite webbrowser or command line tool: $ curl http://localhost:8080/ Hello w\u00f6rld! If everything works as expected, we can continue with writing our first tests to automate this.","title":"Controller classes to structure your app"},{"location":"best-practices/deployment/","text":"Production deployment \u00b6 One of the nice properties of X is that it runs anywhere , i.e. it works both behind traditional web server setups as well as in a stand-alone environment. This makes it easy to get started with existing web application stacks, yet it provides even more awesome features with its built-in web server. Traditional stacks \u00b6 No matter what existing PHP stack you're using, X runs anywhere. This means that if you've already used PHP before, X will just work . nginx with PHP-FPM Apache with PHP-FPM, mod_fcgid, mod_cgi or mod_php Any other web server using FastCGI to talk to PHP-FPM Linux, Mac and Windows operating systems ( LAMP, MAMP, WAMP ) We've got you covered. For example, if you've followed the quickstart guide , you can run this using PHP's built-in development web server for testing purposes like this: $ php -S 0 .0.0.0:8080 app.php In order to check your web application responds as expected, you can use your favorite webbrowser or command line tool: $ curl http://localhost:8080/ Hello w\u00f6rld! Built-in web server \u00b6 But there's more! Framework X ships its own efficient web server implementation written in pure PHP. This uses an event-driven architecture to allow you to get the most out of Framework X. With the built-in web server, we provide a non-blocking implementation that can handle thousands of incoming connections and provide a much better user experience in high-load scenarios. With no changes required, you can run the built-in web server with the exact same code base on the command line: $ php app.php Let's take a look and see this works just like before: $ curl http://localhost:8080/ Hello w\u00f6rld! You may be wondering how fast a pure PHP web server implementation could possibly be. In fact, in benchmarks this setup outperforms any traditional PHP stack by orders of magnitude. The answer: Lightning fast! Listen address \u00b6 By default, X will listen on http://127.0.0.1:8080 , i.e. you can connect to it on the local port 8080 , but you can not connect to it from outside the system it's running on. This is a common approach when running this behind a reverse proxy such as nginx, HAproxy, etc. for TLS termination as discussed in the next chapter. If you want to change the listen address, you can pass an IP and port combination through the X_LISTEN environment variable like this: $ X_LISTEN = 127 .0.0.1:8081 php app.php While not usually recommended, you can also expose this to the public by using the special 0.0.0.0 IPv4 address or [::] IPv6 address like this: $ X_LISTEN = 0 .0.0.0:8080 php app.php Systemd \u00b6 So far, we're manually executing the application server on the command line and everything works fine for testing purposes. Once we're going to push this to production, we should use service monitoring to make sure the server will automatically restart after system reboot or failure. If we're using an Ubuntu- or Debian-based system, we can use the below instructions to configure systemd to manage our server process with just a few lines of configuration, which makes it super easy to run X in production. \u2139\ufe0f Why systemd? There's a large variety of different tools and options to use for service monitoring, depending on your particular needs. Among these is systemd , which is very wide-spread on Linux-based systems and in fact comes preinstalled with many of the large distributions. But we love choice. If you prefer different tools, you can adjust the following instructions to suite your needs. First, start by creating a systemd unit file for our application. We can simply drop the following configuration template into the systemd configuration directory like this: $ sudoedit /etc/systemd/system/acme.service [Unit] Description=ACME server [Service] ExecStart=/usr/bin/php /home/alice/projects/acme/index.php User=alice [Install] WantedBy=multi-user.target In this example, we're assuming the system user alice has followed the quickstart example and has successfully installed everything in the /home/alice/projects/acme directory. Make sure to adjust the system user and paths to your application directory and PHP binary to suite your needs. Once the new systemd unit file has been put in place, we need to activate the service unit once like this: $ sudo systemctl enable acme.service Finally, we need to instruct systemd to start our new unit: $ sudo systemctl start acme.service And that's it already! Systemd now monitors our application server and will automatically start, stop and restart the server application when needed. You can check the status at any time like this: $ sudo systemctl status acme.service \u25cf acme.service - ACME server Loaded: loaded ( /etc/systemd/system/acme.service ; enabled ; vendor preset: enabled ) Active: active ( running ) [ \u2026 ] This should be enough to get you started with systemd. If you want to learn more about systemd, check out the official documentation . Docker containers \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! More \u00b6 If you're going to use this in production, we still recommend running this behind a reverse proxy such as nginx, HAproxy, etc. for TLS termination (HTTPS support).","title":"Production deployment"},{"location":"best-practices/deployment/#production-deployment","text":"One of the nice properties of X is that it runs anywhere , i.e. it works both behind traditional web server setups as well as in a stand-alone environment. This makes it easy to get started with existing web application stacks, yet it provides even more awesome features with its built-in web server.","title":"Production deployment"},{"location":"best-practices/deployment/#traditional-stacks","text":"No matter what existing PHP stack you're using, X runs anywhere. This means that if you've already used PHP before, X will just work . nginx with PHP-FPM Apache with PHP-FPM, mod_fcgid, mod_cgi or mod_php Any other web server using FastCGI to talk to PHP-FPM Linux, Mac and Windows operating systems ( LAMP, MAMP, WAMP ) We've got you covered. For example, if you've followed the quickstart guide , you can run this using PHP's built-in development web server for testing purposes like this: $ php -S 0 .0.0.0:8080 app.php In order to check your web application responds as expected, you can use your favorite webbrowser or command line tool: $ curl http://localhost:8080/ Hello w\u00f6rld!","title":"Traditional stacks"},{"location":"best-practices/deployment/#built-in-web-server","text":"But there's more! Framework X ships its own efficient web server implementation written in pure PHP. This uses an event-driven architecture to allow you to get the most out of Framework X. With the built-in web server, we provide a non-blocking implementation that can handle thousands of incoming connections and provide a much better user experience in high-load scenarios. With no changes required, you can run the built-in web server with the exact same code base on the command line: $ php app.php Let's take a look and see this works just like before: $ curl http://localhost:8080/ Hello w\u00f6rld! You may be wondering how fast a pure PHP web server implementation could possibly be. In fact, in benchmarks this setup outperforms any traditional PHP stack by orders of magnitude. The answer: Lightning fast!","title":"Built-in web server"},{"location":"best-practices/deployment/#listen-address","text":"By default, X will listen on http://127.0.0.1:8080 , i.e. you can connect to it on the local port 8080 , but you can not connect to it from outside the system it's running on. This is a common approach when running this behind a reverse proxy such as nginx, HAproxy, etc. for TLS termination as discussed in the next chapter. If you want to change the listen address, you can pass an IP and port combination through the X_LISTEN environment variable like this: $ X_LISTEN = 127 .0.0.1:8081 php app.php While not usually recommended, you can also expose this to the public by using the special 0.0.0.0 IPv4 address or [::] IPv6 address like this: $ X_LISTEN = 0 .0.0.0:8080 php app.php","title":"Listen address"},{"location":"best-practices/deployment/#systemd","text":"So far, we're manually executing the application server on the command line and everything works fine for testing purposes. Once we're going to push this to production, we should use service monitoring to make sure the server will automatically restart after system reboot or failure. If we're using an Ubuntu- or Debian-based system, we can use the below instructions to configure systemd to manage our server process with just a few lines of configuration, which makes it super easy to run X in production. \u2139\ufe0f Why systemd? There's a large variety of different tools and options to use for service monitoring, depending on your particular needs. Among these is systemd , which is very wide-spread on Linux-based systems and in fact comes preinstalled with many of the large distributions. But we love choice. If you prefer different tools, you can adjust the following instructions to suite your needs. First, start by creating a systemd unit file for our application. We can simply drop the following configuration template into the systemd configuration directory like this: $ sudoedit /etc/systemd/system/acme.service [Unit] Description=ACME server [Service] ExecStart=/usr/bin/php /home/alice/projects/acme/index.php User=alice [Install] WantedBy=multi-user.target In this example, we're assuming the system user alice has followed the quickstart example and has successfully installed everything in the /home/alice/projects/acme directory. Make sure to adjust the system user and paths to your application directory and PHP binary to suite your needs. Once the new systemd unit file has been put in place, we need to activate the service unit once like this: $ sudo systemctl enable acme.service Finally, we need to instruct systemd to start our new unit: $ sudo systemctl start acme.service And that's it already! Systemd now monitors our application server and will automatically start, stop and restart the server application when needed. You can check the status at any time like this: $ sudo systemctl status acme.service \u25cf acme.service - ACME server Loaded: loaded ( /etc/systemd/system/acme.service ; enabled ; vendor preset: enabled ) Active: active ( running ) [ \u2026 ] This should be enough to get you started with systemd. If you want to learn more about systemd, check out the official documentation .","title":"Systemd"},{"location":"best-practices/deployment/#docker-containers","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out!","title":"Docker containers"},{"location":"best-practices/deployment/#more","text":"If you're going to use this in production, we still recommend running this behind a reverse proxy such as nginx, HAproxy, etc. for TLS termination (HTTPS support).","title":"More"},{"location":"best-practices/testing/","text":"Testing \u00b6 \u2139\ufe0f New to testing your web application? While we don't want to force you to test your app, we want to emphasize the importance of automated test suites and try hard to make testing your web application as easy as possible. Tests allow you to verify correct behavior of your implementation, so that you match expected behavior with the actual implementation. And perhaps more importantly, by automating this process you can be sure future changes do not introduce any regressions and suddenly break something else. Develop your application with ease and certainty. We \u2764\ufe0f TDD ! PHPUnit basics \u00b6 Once your app is structured into dedicated controller classes as per the previous chapter, we can test each controller class in isolation. This way, testing becomes pretty straight forward. Let's start simple and write some unit tests for our simple HelloController class: # src/HelloController.php <?php namespace Acme\\Todo ; use React\\Http\\Message\\Response ; class HelloController { public function __invoke () { return new Response ( 200 , [], \"Hello w\u00f6rld! \\n \" ); } } As a first step, we need to install PHPUnit with Composer by running this command in the project directory: $ composer require --dev phpunit/phpunit \u2139\ufe0f New to PHPUnit? If you haven't heard about PHPUnit before, PHPUnit is the testing framework for PHP projects. After installing it as a development dependency, we can take advantage of its structure to write tests for our own application. Next, we can start by creating our first unit test: # tests/HelloControllerTest.php <?php namespace Acme\\Tests\\Todo ; use Acme\\Todo\\HelloController ; use PHPUnit\\Framework\\TestCase ; use Psr\\Http\\Message\\ResponseInterface ; use React\\Http\\Message\\ServerRequest ; class HelloControllerTest extends TestCase { public function testControllerReturnsValidResponse () { $request = new ServerRequest ( 'http://example.com/' ); $controller = new HelloController (); $response = $controller ( $request ); $this -> assertInstanceOf ( ResponseInterface :: class , $response ); $this -> assertEquals ( 200 , $response -> getStatusCode ()); $this -> assertEquals ( \"Hello w\u00f6rld! \\n \" , ( string ) $response -> getBody ()); } } We're intentionally starting simple. By starting with a controller class following a somewhat trivial implementation, we can focus on just getting the test suite up and running first. All following tests will also follow a somewhat similar structure, so we can always use this as a simple building block: create an HTTP request object pass it into our controller function and then run assertions on the expected HTTP response object. Once you've created your first unit tests, it's time to run PHPUnit by executing this command in the project directory: $ vendor/bin/phpunit tests PHPUnit 9.5.4 by Sebastian Bergmann and contributors. . 1 / 1 (100%) Time: 00:00.006, Memory: 4.00 MB OK (1 test, 1 assertion) Testing with specific requests \u00b6 Once the basic test setup works, let's continue with testing a controller that shows different behavior depending on what HTTP request comes in. For this example, we're using request attributes , but the same logic applies to testing different URLs, HTTP request headers, etc.: # src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { return new Response ( 200 , [], \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); } } Again, we create a new test class matching the controller class: # tests/UserControllerTest.php <?php namespace Acme\\Tests\\Todo ; use Acme\\Todo\\UserController ; use PHPUnit\\Framework\\TestCase ; use Psr\\Http\\Message\\ResponseInterface ; use React\\Http\\Message\\ServerRequest ; class UserControllerTest extends TestCase { public function testControllerReturnsValidResponse () { $request = new ServerRequest ( 'http://example.com/users/Alice' ); $request = $request -> withAttribute ( 'name' , 'Alice' ); $controller = new UserController (); $response = $controller ( $request ); $this -> assertInstanceOf ( ResponseInterface :: class , $response ); $this -> assertEquals ( 200 , $response -> getStatusCode ()); $this -> assertEquals ( \"Hello Alice! \\n \" , ( string ) $response -> getBody ()); } } This follows the exact same logic like the previous example, except this time we're setting up a specific HTTP request and asserting the HTTP response contains the correct name. Again, we can run PHPUnit in the project directory to see this works as expected: $ vendor/bin/phpunit tests PHPUnit 9.5.4 by Sebastian Bergmann and contributors. .. 2 / 2 (100%) Time: 00:00.003, Memory: 4.00 MB OK (2 tests, 2 assertions) Further reading \u00b6 If you've made it this far, you should have a basic understanding about how testing can help you develop your application with ease and certainty . We believe mastering TTD is well worth it, but perhaps this is somewhat out of scope for this documentation. If you're curious, we recommend looking into the following topics: TDD Higher-level functional tests Test automation CI / CD","title":"Testing"},{"location":"best-practices/testing/#testing","text":"\u2139\ufe0f New to testing your web application? While we don't want to force you to test your app, we want to emphasize the importance of automated test suites and try hard to make testing your web application as easy as possible. Tests allow you to verify correct behavior of your implementation, so that you match expected behavior with the actual implementation. And perhaps more importantly, by automating this process you can be sure future changes do not introduce any regressions and suddenly break something else. Develop your application with ease and certainty. We \u2764\ufe0f TDD !","title":"Testing"},{"location":"best-practices/testing/#phpunit-basics","text":"Once your app is structured into dedicated controller classes as per the previous chapter, we can test each controller class in isolation. This way, testing becomes pretty straight forward. Let's start simple and write some unit tests for our simple HelloController class: # src/HelloController.php <?php namespace Acme\\Todo ; use React\\Http\\Message\\Response ; class HelloController { public function __invoke () { return new Response ( 200 , [], \"Hello w\u00f6rld! \\n \" ); } } As a first step, we need to install PHPUnit with Composer by running this command in the project directory: $ composer require --dev phpunit/phpunit \u2139\ufe0f New to PHPUnit? If you haven't heard about PHPUnit before, PHPUnit is the testing framework for PHP projects. After installing it as a development dependency, we can take advantage of its structure to write tests for our own application. Next, we can start by creating our first unit test: # tests/HelloControllerTest.php <?php namespace Acme\\Tests\\Todo ; use Acme\\Todo\\HelloController ; use PHPUnit\\Framework\\TestCase ; use Psr\\Http\\Message\\ResponseInterface ; use React\\Http\\Message\\ServerRequest ; class HelloControllerTest extends TestCase { public function testControllerReturnsValidResponse () { $request = new ServerRequest ( 'http://example.com/' ); $controller = new HelloController (); $response = $controller ( $request ); $this -> assertInstanceOf ( ResponseInterface :: class , $response ); $this -> assertEquals ( 200 , $response -> getStatusCode ()); $this -> assertEquals ( \"Hello w\u00f6rld! \\n \" , ( string ) $response -> getBody ()); } } We're intentionally starting simple. By starting with a controller class following a somewhat trivial implementation, we can focus on just getting the test suite up and running first. All following tests will also follow a somewhat similar structure, so we can always use this as a simple building block: create an HTTP request object pass it into our controller function and then run assertions on the expected HTTP response object. Once you've created your first unit tests, it's time to run PHPUnit by executing this command in the project directory: $ vendor/bin/phpunit tests PHPUnit 9.5.4 by Sebastian Bergmann and contributors. . 1 / 1 (100%) Time: 00:00.006, Memory: 4.00 MB OK (1 test, 1 assertion)","title":"PHPUnit basics"},{"location":"best-practices/testing/#testing-with-specific-requests","text":"Once the basic test setup works, let's continue with testing a controller that shows different behavior depending on what HTTP request comes in. For this example, we're using request attributes , but the same logic applies to testing different URLs, HTTP request headers, etc.: # src/UserController.php <?php namespace Acme\\Todo ; use Psr\\Http\\Message\\ServerRequestInterface ; use React\\Http\\Message\\Response ; class UserController { public function __invoke ( ServerRequestInterface $request ) { return new Response ( 200 , [], \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); } } Again, we create a new test class matching the controller class: # tests/UserControllerTest.php <?php namespace Acme\\Tests\\Todo ; use Acme\\Todo\\UserController ; use PHPUnit\\Framework\\TestCase ; use Psr\\Http\\Message\\ResponseInterface ; use React\\Http\\Message\\ServerRequest ; class UserControllerTest extends TestCase { public function testControllerReturnsValidResponse () { $request = new ServerRequest ( 'http://example.com/users/Alice' ); $request = $request -> withAttribute ( 'name' , 'Alice' ); $controller = new UserController (); $response = $controller ( $request ); $this -> assertInstanceOf ( ResponseInterface :: class , $response ); $this -> assertEquals ( 200 , $response -> getStatusCode ()); $this -> assertEquals ( \"Hello Alice! \\n \" , ( string ) $response -> getBody ()); } } This follows the exact same logic like the previous example, except this time we're setting up a specific HTTP request and asserting the HTTP response contains the correct name. Again, we can run PHPUnit in the project directory to see this works as expected: $ vendor/bin/phpunit tests PHPUnit 9.5.4 by Sebastian Bergmann and contributors. .. 2 / 2 (100%) Time: 00:00.003, Memory: 4.00 MB OK (2 tests, 2 assertions)","title":"Testing with specific requests"},{"location":"best-practices/testing/#further-reading","text":"If you've made it this far, you should have a basic understanding about how testing can help you develop your application with ease and certainty . We believe mastering TTD is well worth it, but perhaps this is somewhat out of scope for this documentation. If you're curious, we recommend looking into the following topics: TDD Higher-level functional tests Test automation CI / CD","title":"Further reading"},{"location":"getting-started/quickstart/","text":"Quickstart in 5 minutes \u00b6 Getting started with X is easy! Here's a quick tutorial to get you up and running in 5 minutes or less. Start your timer and here we go! Code \u00b6 In order to first start using X, let's start with an entirely empty project directory. This shouldn't be too confusing, but here's how you can do so on the command line: $ mkdir ~/projects/acme $ cd ~/projects/acme Next, we can start by taking a look at a simple example application. You can use this example to get started by creating a new app.php file in your empty project directory: <?php require __DIR__ . '/vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , function () { return new React\\Http\\Message\\Response ( 200 , [], \"Hello w\u00f6rld! \\n \" ); }); $app -> get ( '/users/{name}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { return new React\\Http\\Message\\Response ( 200 , [], \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); }); $app -> run (); On a code level, this is everything you need to get started. For more sophisticated projects, you may want to make sure to structure your controllers , but the above should be just fine for starters. Installation \u00b6 Next, we need to install X and its dependencies to actually run this project. \u26a0\ufe0f Beta This project is currently in closed beta, so the installation requires a manual step first. This will not be necessary once the project is released to the public. Start by creating a new composer.json in the project directory with the following contents: { \"repositories\" : [ { \"type\" : \"vcs\" , \"url\" : \"https://github.com/clue-access/framework-x\" } ] } Thanks to Composer , this installation only requires a single command. \u2139\ufe0f New to Composer? If you haven't heard about Composer before, Composer is the package manager for PHP-based projects. You can think of it as what NPM is to JavaScript, but better . If you haven't used it before, you have to install a recent PHP version and Composer before you can proceed. On Ubuntu- or Debian-based systems, this would be as simple as this: $ sudo apt install php-cli php-mbstring php-xml composer In your project directory, simply run the following command: $ composer require clue/framework-x:dev-main This isn't NPM, so this should only take a moment or two. Running \u00b6 The next step after installing all dependencies is now to serve this web application. One of the nice properties of this project is that it runs anywhere (provided you have PHP installed of course). For example, you can run the above example using PHP's built-in web server for testing purposes like this: $ php -S 0 .0.0.0:8080 app.php You can now use your favorite web browser or command line tool to check your web application responds as expected: $ curl http://localhost:8080/ Hello w\u00f6rld! And that's it already, you can now stop your timer. If you've made it this far, you should have an understanding of why X is so exciting. As a next step, we would recommend checking out the best practices in order to deploy this to production. Happy hacking!","title":"Quickstart in 5 minutes"},{"location":"getting-started/quickstart/#quickstart-in-5-minutes","text":"Getting started with X is easy! Here's a quick tutorial to get you up and running in 5 minutes or less. Start your timer and here we go!","title":"Quickstart in 5 minutes"},{"location":"getting-started/quickstart/#code","text":"In order to first start using X, let's start with an entirely empty project directory. This shouldn't be too confusing, but here's how you can do so on the command line: $ mkdir ~/projects/acme $ cd ~/projects/acme Next, we can start by taking a look at a simple example application. You can use this example to get started by creating a new app.php file in your empty project directory: <?php require __DIR__ . '/vendor/autoload.php' ; $app = new FrameworkX\\App (); $app -> get ( '/' , function () { return new React\\Http\\Message\\Response ( 200 , [], \"Hello w\u00f6rld! \\n \" ); }); $app -> get ( '/users/{name}' , function ( Psr\\Http\\Message\\ServerRequestInterface $request ) { return new React\\Http\\Message\\Response ( 200 , [], \"Hello \" . $request -> getAttribute ( 'name' ) . \"! \\n \" ); }); $app -> run (); On a code level, this is everything you need to get started. For more sophisticated projects, you may want to make sure to structure your controllers , but the above should be just fine for starters.","title":"Code"},{"location":"getting-started/quickstart/#installation","text":"Next, we need to install X and its dependencies to actually run this project. \u26a0\ufe0f Beta This project is currently in closed beta, so the installation requires a manual step first. This will not be necessary once the project is released to the public. Start by creating a new composer.json in the project directory with the following contents: { \"repositories\" : [ { \"type\" : \"vcs\" , \"url\" : \"https://github.com/clue-access/framework-x\" } ] } Thanks to Composer , this installation only requires a single command. \u2139\ufe0f New to Composer? If you haven't heard about Composer before, Composer is the package manager for PHP-based projects. You can think of it as what NPM is to JavaScript, but better . If you haven't used it before, you have to install a recent PHP version and Composer before you can proceed. On Ubuntu- or Debian-based systems, this would be as simple as this: $ sudo apt install php-cli php-mbstring php-xml composer In your project directory, simply run the following command: $ composer require clue/framework-x:dev-main This isn't NPM, so this should only take a moment or two.","title":"Installation"},{"location":"getting-started/quickstart/#running","text":"The next step after installing all dependencies is now to serve this web application. One of the nice properties of this project is that it runs anywhere (provided you have PHP installed of course). For example, you can run the above example using PHP's built-in web server for testing purposes like this: $ php -S 0 .0.0.0:8080 app.php You can now use your favorite web browser or command line tool to check your web application responds as expected: $ curl http://localhost:8080/ Hello w\u00f6rld! And that's it already, you can now stop your timer. If you've made it this far, you should have an understanding of why X is so exciting. As a next step, we would recommend checking out the best practices in order to deploy this to production. Happy hacking!","title":"Running"},{"location":"integrations/authentication/","text":"Authentication \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! HTTP Basic auth easy to implement Implementation as HTTP middleware recommended JWT and OAuth possible Handling credentials application-specific, may take advantage of database See also sessions","title":"Authentication"},{"location":"integrations/authentication/#authentication","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! HTTP Basic auth easy to implement Implementation as HTTP middleware recommended JWT and OAuth possible Handling credentials application-specific, may take advantage of database See also sessions","title":"Authentication"},{"location":"integrations/database/","text":"Database \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Async APIs with Promises Avoid using blocking PDO, Doctrine and family Major database vendors supported already MySQL Postgres SQLite Redis ClickHouse Future DBAL and ORM","title":"Database"},{"location":"integrations/database/#database","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Async APIs with Promises Avoid using blocking PDO, Doctrine and family Major database vendors supported already MySQL Postgres SQLite Redis ClickHouse Future DBAL and ORM","title":"Database"},{"location":"integrations/filesystem/","text":"Filesystem \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Async APIs with Promises Avoid using blocking fopen() , file_get_contents() and family Few blocking calls can be acceptable See reactphp/filesystem for filesystem prototype Avoid blocking filesystem by using child process See clue/reactphp-s3 for async S3 filesystem API (supporting Amazon S3, Ceph, MiniIO, DigitalOcean Spaces and others)","title":"Filesystem"},{"location":"integrations/filesystem/#filesystem","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Async APIs with Promises Avoid using blocking fopen() , file_get_contents() and family Few blocking calls can be acceptable See reactphp/filesystem for filesystem prototype Avoid blocking filesystem by using child process See clue/reactphp-s3 for async S3 filesystem API (supporting Amazon S3, Ceph, MiniIO, DigitalOcean Spaces and others)","title":"Filesystem"},{"location":"integrations/queueing/","text":"Queueing \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Common requirement to offload work from frontend to background workers Major queue vendors supported already BunnyPHP for AMQP (RabbitMQ) Redis with blocking lists and streams Experimental STOMP support for RabbitMQ, Apollo, ActiveMQ, etc. Future optionally built-in queueing support with no external dependencies, but swappable","title":"Queueing"},{"location":"integrations/queueing/#queueing","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Common requirement to offload work from frontend to background workers Major queue vendors supported already BunnyPHP for AMQP (RabbitMQ) Redis with blocking lists and streams Experimental STOMP support for RabbitMQ, Apollo, ActiveMQ, etc. Future optionally built-in queueing support with no external dependencies, but swappable","title":"Queueing"},{"location":"integrations/sessions/","text":"Sessions \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Session handling common requirement and not hard to implement Implementation as HTTP middleware recommended Handling credentials application-specific, may take advantage of database See also authentication","title":"Sessions"},{"location":"integrations/sessions/#sessions","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Session handling common requirement and not hard to implement Implementation as HTTP middleware recommended Handling credentials application-specific, may take advantage of database See also authentication","title":"Sessions"},{"location":"integrations/templates/","text":"Templates \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Very common requirement, especially for HTML pages Any template language possible Twig Handlebars Mustache Template files often loaded from filesystem (avoid blocking)","title":"Templates"},{"location":"integrations/templates/#templates","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Very common requirement, especially for HTML pages Any template language possible Twig Handlebars Mustache Template files often loaded from filesystem (avoid blocking)","title":"Templates"},{"location":"more/architecture/","text":"Architecture \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! HTTP request response semantics PHP runs everywhere shared nothing execution model (optional) ReactPHP (long-running optional) Async PHP","title":"Architecture"},{"location":"more/architecture/#architecture","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! HTTP request response semantics PHP runs everywhere shared nothing execution model (optional) ReactPHP (long-running optional) Async PHP","title":"Architecture"},{"location":"more/community/","text":"Community \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Framework X will be released as open-source under the permissive MIT license. This means it will be free as in free speech and as in free beer. We believe in open source and made a conscious decision to take this path. Being open-source means we can foster a community to focus on building the best possible framework together. Framework X builds on top of existing open-source projects and we want to give back to this community of awesome engineers and developers. Being open to outside contributions means we can guarantee interoperability with a vivid ecosystem and ensure the longevity of the project. Twitter @x_framework GitHub discussions Support chat GitHub sponsors","title":"Community"},{"location":"more/community/#community","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Framework X will be released as open-source under the permissive MIT license. This means it will be free as in free speech and as in free beer. We believe in open source and made a conscious decision to take this path. Being open-source means we can foster a community to focus on building the best possible framework together. Framework X builds on top of existing open-source projects and we want to give back to this community of awesome engineers and developers. Being open to outside contributions means we can guarantee interoperability with a vivid ecosystem and ensure the longevity of the project. Twitter @x_framework GitHub discussions Support chat GitHub sponsors","title":"Community"},{"location":"more/philosophy/","text":"Our philosophy \u00b6 \u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Motto: make easy things easy & hard things possible From quick prototyping ( RAD ) to production environment in hours Batteries included, but swappable Reuse where applicable, but accept some duplication Long-term support (LTS) and careful upgrade paths Promote best practices, but don't enfore certain style Runs anywhere Open and inclusive community","title":"Our philosophy"},{"location":"more/philosophy/#our-philosophy","text":"\u26a0\ufe0f Documentation still under construction You're seeing an early draft of the documentation that is still in the works. Give feedback to help us prioritize. We also welcome contributors to help out! Motto: make easy things easy & hard things possible From quick prototyping ( RAD ) to production environment in hours Batteries included, but swappable Reuse where applicable, but accept some duplication Long-term support (LTS) and careful upgrade paths Promote best practices, but don't enfore certain style Runs anywhere Open and inclusive community","title":"Our philosophy"}]}